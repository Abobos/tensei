'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('proxy-polyfill');
const Axios = require('axios');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const Axios__default = /*#__PURE__*/_interopDefaultLegacy(Axios);

function getUrlParameter(name) {
  name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
  var results = regex.exec(location.search);
  return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}
class LocalStorageStore {
  constructor(name) {
    this.name = name;
  }
  set(value) {
    localStorage.setItem(this.name, JSON.stringify(value));
  }
  get() {
    try {
      return JSON.parse(localStorage.getItem(this.name) || "");
    } catch (error) {
      return null;
    }
  }
  clear() {
    return localStorage.removeItem(this.name);
  }
}
function isBrowser() {
  return typeof window !== "undefined" && typeof window.document !== "undefined";
}
function getLocation(href) {
  var match = href.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)([\/]{0,1}[^?#]*)(\?[^#]*|)(#.*|)$/);
  return match && {
    protocol: match[1],
    host: match[2]
  };
}
class AuthAPI {
  constructor(instance) {
    this.instance = instance;
    this.session_interval = null;
    this.storage = new LocalStorageStore("___tensei__session___");
    this.loadExistingSession();
  }
  async loadExistingSession() {
    this.silentLogin();
  }
  async login(payload) {
    const response = await this.instance.post("login", payload.object);
    this.auth_response = response.data.data;
    if (payload.skipAuthentication) {
      return response;
    }
    this.setAuthorizationHeader();
    this.authenticateWithRefreshTokens(response.data.data);
    return response;
  }
  async silentLogin() {
    if (!isBrowser()) {
      return;
    }
    const session = this.storage.get();
    if (!session || !this.isSessionValid(session)) {
      return this.logout();
    }
    try {
      const response = await this.refreshToken({ token: session.refresh_token });
      this.auth_response = response.data.data;
      await this.authenticateWithRefreshTokens(response.data.data);
      if (this.on_refresh && this.auth_response) {
        this.on_refresh(this.auth_response);
      }
    } catch (errors) {
      this.logout();
    }
  }
  onRefresh(fn) {
    this.on_refresh = fn;
  }
  setAuthorizationHeader() {
    var _a;
    this.instance.defaults.headers.common = {
      "Authorization": `Bearer ${(_a = this.auth_response) == null ? void 0 : _a.access_token}`
    };
  }
  authenticateWithRefreshTokens(response) {
    var _a;
    this.setAuthorizationHeader();
    if (!isBrowser()) {
      return;
    }
    if (!((_a = this.auth_response) == null ? void 0 : _a.refresh_token)) {
      return;
    }
    const current_time = new Date().toISOString();
    this.storage.set({
      current_time,
      refresh_token: response.refresh_token,
      access_token_expires_in: response.expires_in
    });
    if (this.session_interval) {
      return;
    }
    this.session_interval = setInterval(() => {
      this.silentLogin();
    }, (response.expires_in - 10) * 1e3);
  }
  refreshToken(payload) {
    return this.instance.get("refresh-token", {
      headers: {
        "x-tensei-refresh-token": payload.token
      }
    });
  }
  isSessionValid(session) {
    const token_created_at = new Date(session.current_time);
    token_created_at.setSeconds(token_created_at.getSeconds() + 240);
    return token_created_at > new Date();
  }
  logout(payload = {}) {
    if (this.session_interval) {
      clearInterval(this.session_interval);
    }
    if (isBrowser()) {
      this.storage.clear();
    }
  }
  async register(payload) {
    const response = await this.instance.post("register", payload.object);
    this.auth_response = response.data.data;
    if (payload.skipAuthentication) {
      return response;
    }
    this.authenticateWithRefreshTokens(response.data.data);
    return response;
  }
  forgotPassword(payload) {
    return this.instance.post("passwords/email", payload.object);
  }
  resetPassword(payload) {
    return this.instance.post("passwords/reset", payload.object);
  }
  resendVerificationEmail() {
    return this.instance.post("emails/verification/resend");
  }
  confirmEmail(payload) {
    return this.instance.post("emails/verification/confirm", payload.object);
  }
  enableTwoFactor() {
    return this.instance.post("two-factor/enable");
  }
  confirmTwoFactor() {
    return this.instance.post("two-factor/confirm");
  }
  disableTwoFactor() {
    return this.instance.post("two-factor/disable");
  }
  socialRedirectUrl(provider) {
    const { protocol, host } = getLocation(this.instance.defaults.baseURL);
    return `${protocol}//${host}/connect/${provider}`;
  }
  async handleSocial(type, payload) {
    const response = await this.instance.post(`social/${type}`, payload.object);
    this.auth_response = response.data.data;
    if (payload.skipAuthentication) {
      return response;
    }
    this.setAuthorizationHeader();
    this.authenticateWithRefreshTokens(response.data.data);
    return response;
  }
  async socialLogin(payload) {
    return this.handleSocial("login", this.getSocialPayload(payload));
  }
  async socialRegister(payload) {
    return this.handleSocial("register", this.getSocialPayload(payload));
  }
  getSocialPayload(payload) {
    if (!payload) {
      return {
        object: {
          access_token: getUrlParameter("access_token")
        }
      };
    }
    return payload;
  }
  socialConfirm(payload) {
    return this.handleSocial("confirm", this.getSocialPayload(payload));
  }
}

let dashed = (s) => s.replace(/[A-Z]/g, "-$&").toLowerCase();
class BaseSdk {
  constructor(options) {
    this.options = options;
    var _a;
    this.instance = (options == null ? void 0 : options.axiosInstance) || Axios__default['default'].create({
      baseURL: ((_a = this.options) == null ? void 0 : _a.url) || "http://localhost:8810/api",
      ...(options == null ? void 0 : options.axiosRequestConfig) || {}
    });
    this.authInstance = new AuthAPI(this.instance);
  }
  auth() {
    return this.authInstance;
  }
}
function getSdk(instance, slug) {
  return function() {
    return {
      find(payload = {}) {
        return instance.get(`${slug}/${payload.id}`);
      },
      findMany(payload = {}) {
        var _a, _b, _c, _d;
        return instance.get(slug, {
          params: {
            populate: ((_a = payload == null ? void 0 : payload.populate) == null ? void 0 : _a.join(",")) || [],
            per_page: (_b = payload == null ? void 0 : payload.pagination) == null ? void 0 : _b.per_page,
            page: (_c = payload == null ? void 0 : payload.pagination) == null ? void 0 : _c.page,
            fields: ((_d = payload == null ? void 0 : payload.fields) == null ? void 0 : _d.join(",")) || void 0,
            where: payload == null ? void 0 : payload.where
          }
        });
      },
      insert(payload) {
        return instance.post(slug, payload.object);
      },
      insertMany(payload) {
        return instance.post(`${slug}/bulk`, payload);
      },
      update(payload) {
        return instance.patch(`${slug}/${payload.id}`, payload.object);
      },
      updateMany(payload) {
        return instance.patch(`${slug}/bulk`, payload);
      },
      delete(payload) {
        return instance.delete(`${slug}/${payload.id}`);
      },
      deleteMany(payload) {
        return instance.delete(slug, {
          params: {
            where: payload.where
          }
        });
      }
    };
  };
}
class Sdk extends BaseSdk {
  constructor(options) {
    super(options);
    const { instance } = this;
    return new Proxy(this, {
      get(target, method) {
        if (target[method] === void 0) {
          return getSdk(instance, dashed(method.toString()));
        }
        return target[method];
      }
    });
  }
}

exports.Sdk = Sdk;
